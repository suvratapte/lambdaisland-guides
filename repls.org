#+TITLE: The Ultimate Guide To Clojure REPLs
#+AUTHOR: Arne Brasseur
#+EMAIL: arne@lambdaisland.com
#+LaTeX_CLASS: report
#+LaTeX_HEADER: \usepackage[margin=1in]{geometry}
#+LATEX_HEADER: \input{repls-title}
#+LaTeX_HEADER: \renewcommand*\rmdefault{ppl}
#+LaTeX_HEADER: \usepackage{minted}
#+LaTeX_HEADER: \usemintedstyle{emacs}
#+LaTeX_HEADER: \newminted{common-lisp}{fontsize=\footnotesize}
#+LaTeX_HEADER: \DeclareUnicodeCharacter{2588}{\textblock}

* Export :noexport:

#+BEGIN_SRC emacs-lisp
(lambdaisland/export-guides)
#+END_SRC

#+RESULTS:

* Introduction

  /Version 2016-09-22, 7966 words. Reading time: 50 minutes./

  Interactive development is at the very heart of Clojure's philosophy.
  Exploration, fast feedback, poking at and into a running system, these are the
  bread and butter of Clojure programming, and it all starts with a humble REPL.

  #+BEGIN_SRC text
  user=> â–ˆ
  #+END_SRC

  As the Clojure ecosystem evolved, its REPLs evolved as well. We now have
  network and socket REPLs, browser connected and bootstrapped REPLs, REPLs in
  our editors that power our tools. It's easy to lose track of all the options
  available. What are they for? How do you use them?

  While writing this guide I kept remembering the first time I went to Berlin's
  Clojure Dojo. We didn't have many presentations back then, instead people just
  chose a topic and hacked around. This first time I was there the topic was Om.
  I was eager to get started, but first I wanted to have my trusty Emacs set up.
  I had heard about browser connected REPLs, surely I should be able to set one
  up to help me along the way.

  I spent the whole meetup poring over the READMEs of Austin and Piggieback, not
  making sense of any it. CIDER was still called nREPL.el, which just added to
  the confusion. I went home with a broken setup and a broken heart.

  Things have come a long way since then. So much love and hard work has gone
  into the tooling surrounding Clojure it makes me giddy. Unfortunately there is
  still a lot of confusion as well, and documentation isn't always
  comprehensive. This guide seeks to remedy that. It will give you a map of the
  territory, with clear instructions to help you get where you want to be. I
  hope you'll enjoy the trip.

** What's a REPL?

   A REPL is an interactive prompt, a program which allows you to type in some
   code, and shows you the result of evaluating this code. You are probably
   already familiar with several REPLs, such as the browser console, which
   evaluates JavaScript, or your Terminal (Console, Command Prompt, Shell),
   which evaluates shell code.

   Dynamic programming languages all come with REPLs nowadays, like ~irb~ for
   Ruby, or ~iex~ for Elixir, and LISP languages in particular have a long
   history of using REPLs for interactive development.

** What is it good for?

   REPLs are important because they give you instant feedback. You don't have to
   save, compile, then run. Just type the code and press enter. This encourages
   experimentation. It's the "let's poke at it with a stick" of programming, a
   way of instantly validating, or adjusting, your concept of reality.

   Clojure is especially suitable for this because the representation of its
   values is in turn valid Clojure code, so the return value of a function can
   be easily read and interpreted. Instead of opaque impenetrable objects we
   have simple maps, vectors, sets, with their contents clearly showing.

** How does a REPL work?

   REPL stands for Read-Eval-Print-Loop, this bit of Clojure pseudocode
   demonstrates how a REPL works.

   #+BEGIN_SRC clojure
     (loop [input (read-line-from-stdin)]
       (-> input
           eval-str
           print)
       (recur (read-line-from-stdin)))
   #+END_SRC

   First some code is READ from the input stream, then that code is EVALuated,
   and finally the result is PRINTed on the output stream, before LOOPing back
   and starting over again.

** Contributing to This Guide

   The source for this book is on Github: [[https://github.com/lambdaisland/lambdaisland-guides][lambdaisland/lambdaisland-guides]]. If
   you find a typo, find parts that could be improved or extended, or if you
   want to contribute new sections, then please open a pull request.

   This book is written in org-mode format, so it's easiest to edit it with
   Emacs and org-mode, although it's just plain text so any editor will do. For
   small fixes you can even make the edits directly on Github.

** Changelog

   - *2017-02-21*

     Added a section about [[Lumo][Lumo]] and [[Calvin][Calvin]], expanded the section on [[Planck][Planck]].

     7966 words.

   - *2016-08-20*

     Added a stub about [[ClojureScript clients for nREPL][ClojureScript clients for nREPL]]

   - *2016-08-19*

     Code fix by [[https://github.com/visibletrap][Nuttanart Pornprasitsakul (visibletrap)]] [[https://github.com/lambdaisland/lambdaisland-guides/pull/1][(pull request)]]

   - *2016-08-17*

     Added [[Monroe][Monroe]], started the sections on [[inf-clojure][inf-clojure]] and [[CIDER][CIDER]]. Small fixes
     and cleanup.

     7158 words.

   - *2016-08-16*

     First version

** Todo

   - Dive into ~cljs.repl/doc~ and friends. These are the equivalents of the
     ~clojure.repl~ helpers. Planck makes these available in the ~cljs.user~
     namespace, Figwheel does not. Try out the various ClojureScript repls and
     see how to access these helpers.
   - Add a section on Dirac / cljs-devtools.
   - Add a section on boot-cljs-repl
   - Gorilla REPL
   - crepl

* Clojure REPLs
** Clojure's Built-in REPL
*** Starting the REPL

   A natural starting point is the REPL that comes with Clojure itself. This is
   not the REPL you get with ~lein repl~ though! To see Clojure's built-in REPL
   all we need is the single JAR file which contains Clojure. If you've done any
   Clojure before you probably already have it on your system, you can find it
   with this command

   #+BEGIN_SRC shell
     find ~/.m2 -name clojure-1.*.jar
   #+END_SRC

   If that doesn't yield anything, then download Clojure from [[http://clojure.org/community/downloads][the official
   download page]], extract the zip file, and you should find the JAR in there.

   Now run this command in your terminal, and you should find yourself looking
   at a beautiful Clojure REPL.

   #+BEGIN_SRC shell
     java -jar /path/to/clojure-x.y.z.jar
   #+END_SRC

   For example

   #+BEGIN_SRC shell
     $ java -jar clojure-1.8.0.jar
     Clojure 1.8.0
     user=> (+ 1 1)
     2
     user=>
   #+END_SRC

   If you're curious you can find the implementation in [[https://github.com/clojure/clojure/blob/master/src/clj/clojure/main.clj#L174-L266][clojure.main/repl]].

*** REPL Special Features

   When this REPL starts we are in the ~user~ namespace. Besides the usual stuff
   from ~clojure.core~ there are a few extra functions available to you in this
   namespace. These are all very handy to have around during development, so
   make sure you acquaint yourself with them.

   From ~clojure.repl~

   - ~source~ :: Show the source code of a function. ~(source clojure.main/repl)~.
   - ~apropos~ :: Given a string or regular expression, find all functions that match. ~(apropos "some")~
   - ~doc~ :: Show the documentation for a function, macro, or special form. ~(doc map-indexed)~
   - ~dir~ :: Shows a list of functions and other vars in a certain namespace. ~(dir clojure.string)~
   - ~pst~ :: Given an exception, print its message and stacktrace. ~(try (/ 1 0) (catch Exception e (pst e)))~
   - ~find-doc~ :: Searches all docstrings for a string or regex pattern. ~(find-doc "join")~

   From ~clojure.java.javadoc~

   - ~javadoc~ :: Opens the documentation for a Java class in your browser. ~(javadoc java.util.regex.Pattern)~

   From ~clojure.pprint~

   - ~pprint~ :: Show a "pretty" formatted representation of a value. ~(pprint (mapv #(vec (range % 10)) (range 10)))~
   - ~pp~ :: Pretty print the previous result, same as ~(pprint *1)~

   There are also a few "magic" variables available

   - ~*1~, ~*2~, ~*3~ :: The result of the last, penultimate, and third to last evaluation
   - ~*e~ :: The last uncaught exception

   To exit the REPL, type Ctrl-D.

*** Line Editing and History Support

   When you try to use the arrow keys in the REPL you might end up with
   gibberish ~^[[A~. Clojure's REPL does not come with editing or history
   support out of the box.

   Most REPLs rely on the GNU Readline library for these features, and in the
   Java world there's JLine which emulates Readline.

   There's a nifty little tool called ~rlwrap~, which can add Readline support
   to programs that don't have it themselves. So if you want a Clojure REPL with
   full editing and history support, you can start it like this:

   #+BEGIN_SRC shell
     rlwrap java -jar clojure-1.8.0.jar
   #+END_SRC

** Socket REPL

   When a REPL "reads" and "prints", where does it read from, or print to? The
   answer is: standard input, and standard output.

   Every process gets a byte stream that it can read from called "standard
   input", also called ~STDIN~, ~System.in~ in Java, or ~clojure.core/*in*~ in
   Clojure. If you start a program from a terminal, then this input stream
   receives your keyboard's keystrokes.

   Each process also starts with two output streams, "standard output" and
   "standard error". Standard output (~STDOUT~, ~System.out~,
   ~clojure.core/*out*~) is where the REPL prints its results, and so they show
   up in your terminal.

   So what if you hook something else up as input and output stream? For
   instance, a network socket. Would that still work?

   Turns out it does, and this is what Clojure's Socket REPL can do for you. The
   name Socket REPL is actually misleading, because there is nothing
   REPL-specific about this feature. Instead it's a general facility that causes
   Clojure to start a TCP server, and wait for connections. Whenever a
   connection is received, Clojure will connect ~*in*~ and ~*out*~ to the
   network connection's input and output streams, and then pass control over to
   a chosen function.

   If that function happens to be ~clojure.main/repl~, well, then you've got
   yourself a network REPL!

   You tell Clojure to start a socket REPL using the ~clojure.server.repl~
   property, which you can configure like this:

   #+BEGIN_SRC shell
     java -cp clojure-1.8.0.jar -Dclojure.server.repl="{:port 5555 :accept clojure.core.server/repl}" clojure.main
   #+END_SRC

   When you run that command you will see a REPL appear, but that's not the
   socket REPL we are talking about, it's just the regular REPL started by
   ~clojure.main~. To see the socket REPL in action, open a second terminal, and
   connect to it with Netcat (alternatively you can use telnet)

   #+BEGIN_SRC shell
     nc localhost 5555
   #+END_SRC

   You can even add ~rlwrap~ to the mix to get a feature rich REPL experience.
   The great thing about this socket REPL is that

   1. it works over the network, so you can connect to an app running somewhere else
   2. it doesn't require any source code changes, you can have an app that's
      already fully compiled and deployed, and give it REPL support just by
      adding a command line flag.

   Don't expose this socket REPL to the internet though! Make sure your firewall
   blocks outside traffic to this port, then set up an SSH tunnel between the
   server and your local machine to connect to it.

*** Creating Your Own "Socket REPLs"

   We told Clojure to call the ~clojure.core.server/repl~ function each time it
   receives a new connection. This is just a small variant of
   ~clojure.main/repl~ with some extra initialization. We can also tell Clojure
   to use a different function.

   Create a file called ~wrapple.clj~ in the current directory.

   #+BEGIN_SRC clojure
     (ns wrapple)

     (defn echo-time []
       (println (.toString (java.util.Date.))))
   #+END_SRC

   Now start a "socket REPL" using this function:

   #+BEGIN_SRC shell
     java -cp clojure-1.8.0.jar:. -Dclojure.server.repl="{:port 5555 :accept wrapple/echo-time}" clojure.main
   #+END_SRC

   And you've got yourself a network service that echos the time!

   #+BEGIN_SRC shell
     $ nc localhost 5555
     Thu Jul 07 16:22:17 CEST 2016
   #+END_SRC

   We can even make our own REPL loop, like this one, which will turn anything
   you give it into uppercase.

   #+BEGIN_SRC clojure
     (ns wrapple
       (:require [clojure.string :as str]))

     (defn prompt-and-read []
       (print "~> ")
       (flush)
       (read-line))

     (defn uprepl []
       (loop [input (prompt-and-read)]
         (-> input
             str/upper-case
             println)
         (recur (prompt-and-read))))
   #+END_SRC

   #+BEGIN_SRC shell
     java -cp clojure-1.8.0.jar:. -Dclojure.server.repl="{:port 5555 :accept wrapple/uprepl}" clojure.main
   #+END_SRC

   #+BEGIN_SRC shell
     $ nc localhost 5555
     ~> isn't this awesome?
     ISN'T THIS AWESOME?
     ~>
   #+END_SRC

** nREPL

   nREPL stands for "network REPL", and while this may sound pretty similar to a
   "socket REPL", they are completely different animals.

   The REPLs we've seen so far are stream based, they read lines from an input
   stream, and write the result (and any output from side effects) to an output
   stream. This makes them conceptually simple, but tedious to communicate with
   programmatically.

   nREPL seeks to fix this by being message-based, putting program-to-program
   first through a client-server architecture, where the client is your editor
   or IDE, and the server is the nREPL "REPL".

   The client initiates the interaction by sending a message to the server, and
   as a response the server will send one or more messages back to the client.

   The easiest way to start an nREPL server is either through Leiningen (~lein
   repl~) or Boot (~boot repl~). In either case the first line of output will
   contain a port number that an nREPL client can connect to.

*** Messages

   A message might look something like this.

   #+BEGIN_SRC clojure
     {:id "10"
      :op "eval"
      :code "(+ 1 1)\n"
      :ns "user"}
   #+END_SRC

   nREPL supports a number of "operations", the quintessential being "eval",
   which simply evaluates some code.

   Conceptually a message is like a Clojure map, a set of key-value pairs. The
   precise keys used depend on the type of message. In the case of ~eval~ it
   needs to know the code to evaluate, as well as the namespace to use for
   context.

   The response will look something like this.

   #+BEGIN_SRC clojure
     {:id "10"
      :out "2\n"}
   #+END_SRC

   An editor or IDE could provide a Clojure REPL by implementing Read, Print,
   and Loop, and letting nREPL handle the Evaluate part, but it can do much more
   than just emulating a traditional REPL. nREPL can power "live" evaluation
   (sending forms from an editor buffer directly to a Clojure process), it can
   be used to look up documentation, inspect a running program, and much more.

   nREPL provides a range of operations beyond "eval", together they can be used
   to offer rich Clojure editing support. Through "nREPL middleware" it is
   possible to add support for new operations.

   nREPL supports these operations out of the box

   - ~eval~ :: Evaluate some code, returns the output value
   - ~interrupt~ :: Attempt to interrupt the current ~eval~ operation
   - ~describe~ :: Returns a list of currently supported operations, as well
        version information
   - ~load-file~ :: (re-)load a complete source file

*** Sessions

   nREPL comes with a built-in "session" middleware. This way you can have
   multiple REPLs backed by a single nREPL server. The session middleware adds
   three operations

   - ~ls-session~ :: list the current sessions
   - ~clone~ :: create a new session
   - ~close~ :: close a session

   Each message will now carry a session-id. This becomes important when dealing
   with the standard in- and output streams, ~*in*~, ~*out*~, and ~*err*~.

   A single ~eval~ operation might cause many lines of output, possibly
   asynchronously, so they arrive after the ~eval~ has completed. The session
   middleware will intercept this output, and send it back to the client with
   the same session-id as the original ~eval~ message.

   Here's an example interaction, evaluating the code

   #+BEGIN_SRC clojure
     (dotimes [i 3]
       (Thread/sleep 1000)
       (println (str "==> " i)))
   #+END_SRC

   I'm using the message representation used by CIDER, with ~-->~ indicating a
   message to the server, and ~<--~ being a message sent back to the client.

   #+BEGIN_SRC clojure
     (-->
       ns  "user"
       op  "eval"
       session  "10299efe-8f84-4b97-814c-21eb6860223b"
       code  "(dotimes [i 3] (Thread/sleep 1000) (println (str \"==> \" i)))\n"
       file  "*cider-repl localhost*"
       line  53
       column  6
       id  "15"
     )
     (<--
       id  "15"
       out  "==> 0\n"
       session  "10299efe-8f84-4b97-814c-21eb6860223b"
     )
     (<--
       id  "15"
       out  "==> 1\n"
       session  "10299efe-8f84-4b97-814c-21eb6860223b"
     )
     (<--
       id  "15"
       out  "==> 2\n"
       session  "10299efe-8f84-4b97-814c-21eb6860223b"
     )
     (<--
       id  "15"
       ns  "user"
       session  "10299efe-8f84-4b97-814c-21eb6860223b"
       value  "nil"
     )
     (<--
       id  "15"
       session  "10299efe-8f84-4b97-814c-21eb6860223b"
       status  ("done")
     )
   #+END_SRC

*** Custom Middleware

   Through "nREPL middleware" you can even implement your own operations. Some notable "middlewares" are ~piggieback~, ~cider-nrepl~, and
   ~nrepl-refactor~. Here's an example of the "eldoc" operation provided by CIDER-nREPL.

   #+BEGIN_SRC clojure
     (-->
       op  "eldoc"
       session  "ff822558-e885-49ed-8cf6-b5331bc8553b"
       ns  "user"
       symbol  "str"
       id  "10"
     )
     (<--
       docstring  "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args."
       eldoc  (nil
      ("x")
      ("x" "&" "ys"))
       id  "10"
       name  "str"
       ns  "clojure.core"
       session  "ff822558-e885-49ed-8cf6-b5331bc8553b"
       status  ("done")
       type  "function"
     )
   #+END_SRC

   Writing your own middleware isn't hard. Let's make a middleware that adds a
   "classpath" operation, which returns the current Java classpath. It's trivial
   but perhaps not altogether useless.

   #+BEGIN_SRC clojure
     (ns classpath-nrepl.middleware
       (:require [clojure.tools.nrepl
                  [middleware :refer [set-descriptor!]]
                  [transport :as transport]]))

     (defn wrap-classpath [handler]
       (fn [{:keys [id op transport] :as request}]
         (if (= op "classpath")
           (transport/send transport {:id id
                                      :classpath (->> (java.lang.ClassLoader/getSystemClassLoader)
                                                       .getURLs
                                                       (map str))})
           (handler request))))

     (set-descriptor! #'wrap-classpath
       {:requires #{}
        :expects #{}
        :handles {"classpath" {:doc "Return the Java classpath"}}})
   #+END_SRC

   At the heart of any nREPL server is the "handler", a function which handles a
   single incoming message. A middleware is a function which takes the existing
   handler function and "wraps" it, returning a new handler function.

   Our new handler will look at each incoming request, and if the operation is
   anything but classpath, it simply calls the old handler. It's basically
   saying, "I don't care about this request, you handle it!"

   When it receives a ~classpath~ message however, then it constructs a
   response, and sends it back to the client.

   As part of the incoming request the handler received a "transport" object,
   which it needs to use to reply to the client. This is how nREPL achieves
   asynchrony. A handler can send several messages back to the client based on a
   single incoming message, possibly much later or from another thread. It only
   needs to make sure to use the transport and id of the original message.

   To see this middleware in action, make sure you have ~tools.nrepl~ in your
   dependencies, and add some ~:repl-options~ to your Leiningen ~project.clj~ to
   insert the middleware into the "middleware stack".

   #+BEGIN_SRC clojure
     (defproject middleware-test "0.1.0-SNAPSHOT"
       :dependencies [[org.clojure/clojure "1.8.0"]
                      [org.clojure/tools.nrepl "0.2.12"]]

       :repl-options {:nrepl-middleware [classpath-nrepl.middleware/wrap-classpath]})
   #+END_SRC

   If you're using Boot then you can insert the middleware like this in your ~build.boot~

   #+BEGIN_SRC clojure
     (require 'boot.repl)

     (swap! boot.repl/*default-middleware*
            conj 'classpath-nrepl.middleware/wrap-classpath)
   #+END_SRC

   If you're starting your own ~tools.nrepl~ server directly instead of using
   ~lein repl~ or ~boot repl~, then you can pass the middleware as an argument
   to the "default handler".

   #+BEGIN_SRC clojure
     (require '[clojure.tools.nrepl.server :as nrepl])
     (require '[classpath-nrepl.middleware :refer [wrap-classpath]])

     (nrepl/start-server :handler (server/default-handler #'wrap-classpath))
   #+END_SRC

   Now start a REPL with ~lein repl~, and note the port number that Leiningen
   prints in the first line of output, for example ~nREPL server started on port
   41065 on host 127.0.0.1~. Now you can connect to it, either from the same
   process, or from a completely different REPL.

   #+BEGIN_SRC clojure
     user> (require '[clojure.tools.nrepl :as repl])
     nil
     user> (def conn (repl/connect :port 41065))
     #'user/conn
     user> (repl/message (repl/client conn 1000) {:id 1 :op "classpath"})
     ({:classpath ["file:/home/arne/.m2/repository/org/clojure/clojure/1.8.0/clojure-1.8.0.jar" ,,,], :id 1})
   #+END_SRC

   Here's what the interaction looks like:

   #+BEGIN_SRC clojure
     (-->
       op  "classpath"
       session  "ff822558-e885-49ed-8cf6-b5331bc8553b"
       id  "1"
     )
     (<--
       classpath  ("/home/arne/.m2/repository/org/clojure/clojure/1.8.0/clojure-1.8.0.jar" ...)
       id  "1"
       session  "ff822558-e885-49ed-8cf6-b5331bc8553b"
       status  ("done")
     )
   #+END_SRC

**** Notable middleware

     The CIDER-nREPL README has a [[https://github.com/clojure-emacs/cider-nrepl#supplied-nrepl-middleware][list of included middlewares and their supported operations]].

     Many more operations are added by [[https://github.com/clojure-emacs/refactor-nrepl][cider-nrepl]].

     [[https://github.com/cemerick/piggieback][Piggieback]] allows using nREPL with ClojureScript, see the Piggieback section
     under ClojureScript REPLs.

*** Protocol

    Messages between an nREPL client and server are sent over the wire using
    "[[https://en.wikipedia.org/wiki/Bencode][BEncode]]" (pronounced B-encode). BEncode was originally developed for use in
    BitTorrent, it's a binary format that supports integers, strings, lists, and
    dictionaries.

    While BEncode is a binary protocol, not intended for human consumption, it
    is kind of readable if you know what you're looking for.

    Take this Clojure Map

    #+BEGIN_SRC clojure
      {:id 1 :op "eval" :code "(+ 1 1)\n"}
    #+END_SRC

    Here's the BEncoding of it

    #+BEGIN_SRC clojure
      "d4:code8:(+ 1 1)\n2:idi1e2:op4:evale"
    #+END_SRC

    The way to read this is

    - ~d~ dictionary
      - ~4:code~ a 4 byte string: ~"code"~
      - ~8:(+ 1 1)\n~ an 8 byte string: ~"(+ 1 1)\n"~
      - ~2:id~ a 2 byte string: ~"id"~
      - ~i1e~ an integer, ~1~
      - ...
    - ~e~ end of dictionary

*** Clients

    It should be clear by now that communicating with nREPL is best done through
    a dedicated client library. The [[https://github.com/clojure/tools.nrepl][tools.nrepl]] package contains both the nREPL
    server and a client implementation that you can use from Clojure.

    - [[https://github.com/clojure-emacs/cider-nrepl][CIDER-nREPL]] contains an implementation for Emacs LISP. If you want to
      experiment with nREPL from Emacs you can try this snippet

      #+BEGIN_SRC emacs-lisp
        (nrepl-send-request '("op" "classpath") (lambda (&more) ) (car (cider-connections)))
      #+END_SRC

      And inspect the ~*nrepl-messages*~ buffer

    - [[https://github.com/technomancy/grenchman][OCaml: grenchman contains an nREPL client]]
    - [[https://github.com/sdegutis/LVReplClient][Objective-C: LVReplClient]]
    - [[https://github.com/cemerick/nrepl-python-client][Python: python-nrepl-client]]
    - [[https://github.com/nullstyle/nrepl][Ruby: experimental client]]
    - [[https://www.npmjs.com/package/nrepl-client][Node.js: nrepl-client on npm]]

    The CIDER README lists [[https://github.com/clojure/tools.nrepl#connecting-to-an-nrepl-server][editors and tools that support nREPL]].

*** ClojureScript clients for nREPL

    /Advanced, you can safely skip this section./

    /This section is a stub, you can [[Contributing to This Guide][help by expanding it]]./

    This section is about connecting to an nREPL server from a ClojureScript
    client. If instead you want your nREPL server to use a ClojureScript
    environment to do evaluation, see the section on [[Piggieback][Piggieback]].

    By default nREPL communicates over TCP sockets, using Bencode as its data
    format. Raw TCP sockets are not available from a browser, but they are
    available in Node.js. You can use the [[https://www.npmjs.com/package/nrepl-client][nrepl-client]] package on NPM to connect
    from Node.js to an nREPL server.

    The nREPL transport is pluggable, so a more browser friendly alternative
    would be to use HTTP over JSON, which is what [[https://github.com/cemerick/drawbridge][Drawbridge]] provides. It is
    implemented as a Ring handler, so you need to use it in conjunction with a
    Ring server adapter (Jetty, Http-kit, Aleph, ...)

    Drawbridge contains an nREPL client that uses the same transport, but that
    one is for Clojure, not ClojureScript. For a ClojureScript client you can
    use [[https://github.com/hiredman/drawbridge-cljs][drawbridge-cljs]].


* ClojureScript REPLs
** ClojureScript Built-in REPLs

   ClojureScript is a variant of the Clojure language, which compiles (or
   "transpiles") to JavaScript code. That way you can write Clojure code, but
   run it anywhere JavaScript is available. It turns out that's quite a lot of
   places.

   When it comes to ClojureScript REPLs the story becomes a bit more involved.
   The ClojureScript compiler is written in Clojure, so it lives in the same
   environment Clojure lives in: the JVM (Java Virtual Machine).

   To evaluate compiled ClojureScript code, which has now turned into
   JavaScript, we need a separate JavaScript environment.

   So a ClojureScript REPL consists of two parts: the first part is written in
   Clojure, it handles the REPL UI, and takes care of compiling ClojureScript to
   JavaScript. This JavaScript code then gets handed over to the second part,
   the JavaScript environment, which evaluates the code and hands back the
   result.

   ClojureScript comes bundled with support for three JavaScript environments:
   Rhino, Node.js, and the browser.

*** Rhino

    [[https://en.wikipedia.org/wiki/Rhino_(JavaScript_engine)][Rhino]] is a JavaScript engine written in Java. The project was started by
    Netscape in 1997, and is now managed by Mozilla. It comes bundled with Java
    (JDK or JRE), so if you have Java you should have Rhino available.

    Assuming your project includes ClojureScript, getting a Rhino-based REPL
    going is as easy as

    #+BEGIN_SRC clojure
      (require '[cljs.repl :as repl])
      (require '[cljs.repl.rhino :as rhino])

      (repl/repl (rhino/repl-env))
    #+END_SRC

    Notice how there are clearly two parts, the ~repl/repl~ function takes a
    JavaScript environment as its argument.

    Rhino is a good option if you want a quick ClojureScript REPL to experiment
    with, but it has its limitations. Since it's not tied to a browser there is
    no DOM, and although people are still working on Rhino, don't expect your
    favorite HTML5 or ES6 features to be available.

    One fun thing you get with Rhino (a gimmick, really), is Java interop!
    That's right, you can use all your favorite Java classes straight from
    ClojureScript.

    #+BEGIN_SRC clojure
      cljs.user> (def f (js/java.io.File. "/etc/hosts"))
      #'cljs.user/f
      cljs.user> (.exists f)
      true
    #+END_SRC

*** Node.js

    The most popular JavaScript engine outside the browser is without a doubt
    Node.js. To get a Node.js-based REPL going you have a couple of options.
    There's a [[https://github.com/bodil/cljs-noderepl][leiningen plugin called cljs-noderepl]], and then there is [[Lumo][Lumo]], a
    standalone Node.js based REPL which will be covered in the section
    on [[Bootstrapped ClojureScript REPLs][Bootstrapped ClojureScript REPLs]].

    It's easy enough to do it youreslf though. To run your own node-based REPL
    simply swap out the Rhino env from the previous section with the Node.js
    repl-env.

    #+BEGIN_SRC clojure
      (require 'cljs.repl)
      (require 'cljs.repl.node)

      (cljs.repl/repl (cljs.repl.node/repl-env))
    #+END_SRC

    Assuming you have a recent enough (>= 0.12.0) Node.js on your system, this
    will spin up node in the background and drop into a REPL. There's still no
    DOM since we're not targeting a browser, but you should get significantly
    better performance, and you have access to the Node APIs, so you can do
    things like access the network or work with files.

    If your ClojureScript project targets Node.js, you will want a REPL that has
    your project code loaded. The [[https://clojurescript.org/guides/quick-start#running-clojurescript-on-node.js][ClojureScript Quick Start]] page provides more
    info.

*** Browser connected REPL

    ClojureScript also comes with a REPL environment that uses a running web
    browser to evaluate expressions typed in to the REPL. This is especially
    useful because it allows you to inspect the state of, and interact with, a
    running web app.

    Just like with Rhino or Node.js there's a ~repl-env~ function that you can
    plug into ~cljs.repl/repl~, this particular ~repl-env~ is defined in
    ~cljs.repl.browser~.

    #+BEGIN_SRC clojure
      (require 'cljs.repl)
      (require 'cljs.repl.browser)

      (cljs.repl/repl (cljs.repl.browser/repl-env))
    #+END_SRC

    This time the REPL won't immediately pop up though, instead it spins up a
    web server and waits for the browser app to connect back to it, so somewhere
    in the ClojureScript code for your web app you'll have to initiate this
    connection.

    #+BEGIN_SRC clojure
      (ns repl-test.core
        (:require [clojure.browser.repl :as repl]))

      (defonce conn
        (repl/connect "http://localhost:9000/repl"))
    #+END_SRC

    You'll need a build script (or use something like ~lein-cljsbuild~) to
    compile this code, and an ~index.html~ to deliver it to the browser. The
    [[https://github.com/clojure/clojurescript/wiki/Quick-Start#browser-repl][relevant section in the ClojureScript Quick Start guide]] goes into greater
    depth about how to do this, including stand-alone examples.

    In HTTP interactions are always initiated by the client. To enable the REPL
    (the server) to send data back to the browser (the client), it uses a
    technique called "long-polling". With this technique the client will
    initiate an HTTP request, and wait as long as necessary for the server to
    respond. This effectively reverses the role of client and server.

    It's a crude mechanism, but has the benefit that it works across browsers.
    Newer ClojureScript REPLs like [[Weasel][Weasel]] and [[Figwheel][Figwheel]] use websockets which are
    ideal for this use case, but only supported in more recent browsers.

    The HTTP server that the REPL uses is often not the one serving up your
    application, and so it will have a different domain or port. For security
    reasons browsers will prevent these two from interacting with each other,
    this is called the same-origin policy. To circumvent this restriction
    ~cljs.repl.browser~ uses ~CrossPageChannel~, a part of the Google Closure
    Library. ~CrossPageChannel~ allows scripts from different origins to
    communicate via an ~iframe~.

** Piggieback

   If you haven't read the section about [[nREPL][nREPL]] yet you better go and read that
   first.

   Piggieback forms the bridge between ClojureScript and nREPL. It's an nREPL
   middleware which intercepts "eval" messages, and routes them to a
   ClojureScript REPL. Most editors and IDEs for Clojure are based on nREPL, so
   you'll need Piggieback to use them with ClojureScript.

   There are two steps to using Piggieback. First make sure the Piggieback
   middleware is added to the middleware stack when starting the nREPL server.
   Now when you start nREPL Piggieback will be dormant, waiting to be woken up.

   Calling ~(cemerick.piggieback/cljs-repl (repl-env))~ from the REPL spurs
   Piggieback into action. From now on any code that's being evaluated will be
   passed to the given ClojureScript REPL env.

   How to add the nREPL middleware depends on how you're starting nREPL.

   In Leiningen the project map takes a ~:repl-options~ key where you can
   configure middleware that will be added to the default stack when running
   ~lein repl~.

   #+BEGIN_SRC clojure
     (defproject cljsrepl "0.1.0"
       :dependencies [[org.clojure/clojure "1.8.0"]
                      [org.clojure/clojurescript "1.9.183"]
                      [com.cemerick/piggieback "0.2.1"]]
       :repl-options {:nrepl-middleware [cemerick.piggieback/wrap-cljs-repl]})
   #+END_SRC

   In Boot ~boot.repl/*default-middleware*~ can be modified to insert
   middleware. Here's a sample ~build.boot~. You can also configure this for all
   projects at once in ~\~/boot/profile.boot~.

   #+BEGIN_SRC clojure
     (require 'boot.repl)

     (swap! boot.repl/*default-dependencies*
            concat '[[com.cemerick/piggieback "0.2.1"][com.cemerick/piggieback "0.2.1"]])

     (swap! boot.repl/*default-middleware*
            conj 'cemerick.piggieback/wrap-cljs-repl)
   #+END_SRC

   If you're starting your own nREPL server then pass the middleware to the
   ~default-handler~

   #+BEGIN_SRC clojure
     (require '[clojure.tools.nrepl.server :as nrepl]
              '[cemerick.piggieback :as piggieback])

     (nrepl/start-server :handler (server/default-handler piggieback/wrap-cljs-repl))
   #+END_SRC

   Now start your REPL (whichever way you choose), and evaluate
   ~(cemerick.piggieback/cljs-repl)~, passing in the ClojureScript repl-env you
   would like to use. This signals to Piggieback that it should start
   intercepting and redirecting "eval" type messages.

   To get your regular Clojure REPL back type ~:cljs/quit~.

   #+BEGIN_SRC clojure
     $ boot repl
     nREPL server started on port 44543 on host 127.0.0.1 - nrepl://127.0.0.1:44543
     REPL-y 0.3.7, nREPL 0.2.12
     Clojure 1.7.0
     OpenJDK 64-Bit Server VM 1.8.0_91-8u91-b14-3ubuntu1~16.04.1-b14
             Exit: Control+D or (exit) or (quit)
         Commands: (user/help)
             Docs: (doc function-name-here)
                   (find-doc "part-of-name-here")
     Find by Name: (find-name "part-of-name-here")
           Source: (source function-name-here)
          Javadoc: (javadoc java-object-or-class-here)
         Examples from clojuredocs.org: [clojuredocs or cdoc]
                   (user/clojuredocs name-here)
                   (user/clojuredocs "ns-here" "name-here")
     boot.user=> (require 'cemerick.piggieback)
     nil
     boot.user=> (require '[cljs.repl.node])
     nil
     boot.user=> (cemerick.piggieback/cljs-repl (cljs.repl.node/repl-env))
     ClojureScript Node.js REPL server listening on 58146
     To quit, type: :cljs/quit
     nil
     cljs.user=>

     cljs.user=> (+ 1 1)
     2
     cljs.user=> :cljs/quit
     nil
     boot.user=>
   #+END_SRC

** Austin

   [[https://github.com/cemerick/austin][Austin]] (apparently named after a [[https://en.wikipedia.org/wiki/The_Six_Million_Dollar_Man][sci-fi character from the 70's]]) is an
   alternative to the built-in browser REPL, trying to improve upon it in
   several ways. Since the project came out some other alternatives have come
   onto the scene, notably [[Weasel][Weasel]] and [[Figwheel][Figwheel]], and unless you have specific
   reaons to choose Austin for your REPL needs you're probably better off with
   something else. Nevertheless Austin introduced some important ideas, which
   are worth looking into.

   Browser connected REPLs were introduced as a way to interact with the
   application running in the browser. It can however also be useful to have a
   independent REPL that still has access to all your project's namespaces, and
   that runs in an environment with a DOM, but without booting the app.

   This kind of "project REPL" is good for quickly trying stuff out, playing
   around with libraries, or running tests.

   The killer feature of Austin is making it easy to start such a Project REPL.

   Calling ~(cemerick.austin.repls/exec)~ will spin up a PhantomJS (or
   compatible) "headless" browser in the background, and connect to that.
   PhantomJS uses WebKit, the browser engine used by Safari and (before the
   fork) Chrome, so it has a full DOM available, but it's headless, so there is
   no browser window.

   Austin can run multiple REPLs in parallel, and will provide specific entry
   point URLs for each. This means you don't have to manually add client code to
   connect back to the server.

   There's a [[http://www.youtube.com/watch?v=a1Bs0pXIVXc][screencast by Chas Emerick, the Author of Austin and Piggieback]]
   that shows off more of its features. Austin still uses the same long-polling
   and CrossPageChannel based approach that ~cljs.repl.browser~ uses.

** Weasel

   [[https://github.com/tomjakubowski/weasel][Weasel]] was the first to replace the long-polling approach with WebSockets.
   While this prevents it from being used in pre-websocket browsers, it does
   open up several JavaScript environments which do have websockets, but don't
   have a DOM, prohibiting the use of ~CrossPageChannel~'s iframe hack.

   Using Weasel is very similar to using other ClojureScript REPL, it's just
   another ~repl-env~ that's made available to you. The Weasel README heavily
   hints at using it with Piggieback, but if you don't need nREPL you can use it
   with the standard cljs-repl just the same.

   Just like with the built-in browser connected REPL, there's a server and
   a client part.

   *Server (Clojure)*

   #+BEGIN_SRC clojure
   (cljs.repl/repl (weasel.repl.websocket/repl-env :ip "0.0.0.0" :port 9001))
   #+END_SRC

   *Client (ClojureScript)*

   #+BEGIN_SRC clojure
     (ns main
       (:require [weasel.repl :as repl]))

     (when-not (repl/alive?)
       (repl/connect "ws://localhost:9001"))
   #+END_SRC

** Figwheel

   [[https://github.com/bhauman/lein-figwheel][Figwheel]] is a Leiningen plugin that automatically pushes code changes to the
   browser, so you get instant feedback. Figwheel also ships with its own
   browser connected REPL, making it a great one stop shop for ClojureScript
   development.

   Considering the amount of work it takes care of you might think it's
   complicated to set up, but the opposite is true. Figwheel is incredibly easy
   to use, and has really made it easier for people to get an interactive
   ClojureScript environment up and running.

   The easiest way to use Figwheel is through its leiningen plugin, just add the
   latest version to your Leiningen's plugin vector

   #+BEGIN_SRC clojure
     (defproject ,,,
       :plugins [[lein-figwheel "0.5.4-7"]])
   #+END_SRC

   And start it with ~lein figwheel~. This will do an initial compilation of
   your ClojureScript code, start a browser connected REPL, and it will even
   open the browser for you so you don't have to figure out what URL to connect
   to.

   Before you do that you'll need to configure a ClojureScript build though, and
   add ~:figwheel true~ to the build configuration. Check out the [[https://github.com/bhauman/lein-figwheel][Figwheel
   README]] for an example, or if you're starting with a new project use a
   pre-existing template, e.g. ~lein new figwheel my-project~ or ~lein new
   chestnut my-project~.

   Using Figwheel with nREPL is a bit more involved, if you need nREPL support,
   e.g. for using Figwheel with CIDER, I can recommend the [[https://github.com/plexus/chestnut][Chestnut]] template.
   For the full low-down check out the [[https://github.com/bhauman/lein-figwheel/wiki/Using-the-Figwheel-REPL-within-NRepl][Figwheel wiki page on using it with nREPL]].

   Figwheel is Piggieback-aware, meaning if you start Figwheel from an nREPL
   based REPL (using the ~figwheel-sidecar~ library), and the piggieback
   middleware is loaded, then Figwheel will automatically do the right thing.

   Figwheel uses WebSockets just like [[Weasel][Weasel]].

** cljs-nashorn

   Java comes bundled not with one, but with two JavaScript environments. We
   already covered the first one, [[Rhino][Rhino]]. The other one is called Nashorn (German
   for "Rhino") and is said to be a faster, more modern implementation.

   While ClojureScript comes with Rhino support out of the box, for Nashorn you
   need a third-party implementation.

   The [[https://github.com/bodil/cljs-nashorn][cljs-nashorn README]] has all the info you need. You can either use the
   Leiningen plugin, or manually set up the Nashorn environment and plug it into
   ~cljs.repl/repl~.

** Further Reading

   The ClojureScript wiki has several interesting pages about its REPLs

   - [[https://github.com/clojure/clojurescript/wiki/Quick-Start][Quick Start]]

     A must read for every serius ClojureScript developer. Teaches you how to
     use the compiler and built-in REPLs from the ground up.

   - [[https://github.com/clojure/clojurescript/wiki/The-REPL-and-Evaluation-Environments][The REPL and Evaluation Environments]]

     Explains the ~IJavaScriptEnv~ Protocol, and has a full example of using
     ~cljs.repl.browser~, as well as explaining several of its implementation
     details.

   - [[https://github.com/clojure/clojurescript/wiki/Custom-REPLs][Custom REPLS]]

     Explains several things to be aware of when developing ClojureScript REPLs.

* Bootstrapped ClojureScript REPLs

  ClojureScript is a compiler (or transpiler, if you will), that turns
  ClojureScript code into JavaScript. This ClojureScript compiler is written in
  Clojure, meaning you still need a Java environment to run it. Only after the
  compilation is done can you forget about Java and just run the target
  JavaScript code on your favorite JavaScript environment.

  Clojure and Java have provided a solid foundation for developing
  ClojureScript, much of the Clojure infrastructure could be reused, and the
  Google Closure Compiler, a Java project, has been indispensable for providing
  optimized output.

  Still the dependency on a Java environment has some downsides. The startup
  time of the JVM is notorious, and while it's possible to run compiled
  ClojureScript code without a JVM, it's not possible in that case to compile
  new code on the fly. For a long time this prohibited building
  pure-ClojureScript REPLs.

  To address these issues, "bootstrapped" ClojureScript was introduced. In the
  context of compilers "being bootstrapped" means that a compiler is able to
  compile its own source. This is also called "self-hosting". If ClojureScript
  compiler can compile itself, than the result is a ClojureScript compiler that
  can run on JavaScript, instead of Java. (remember that Java relates to
  JavaScript like carpet relates to car, we're talking about two very different
  animals here.)

  Some key parts of the infrastructure had to be ported to CLJS (or CLJC), but
  now that bootstrapped ClojureScript is a fact this opens up some exciting new
  possibilities. Note that for typical production app, the Java-based
  ClojureScript compiler is still, and probably always will be, the way to go.
  For building ClojureScript REPLs in JavaScript environments however it's a
  perfect choice.

** Planck

   [[http://planck-repl.org/][Planck]] is a ClojureScript REPL that runs in your terminal and is based on
   JavaScriptCore, the JS engine that ships with WebKit. It is available for Mac
   and Linux.

   Planck's developer, Mike Fikes, has gone through great lengths to build a
   polished, user-friendly product. This is one of the most "modern" Clojure*
   REPLs, featuring colorized output, pretty printing of results, and
   readline-like line editing and history search based on [[https://github.com/antirez/linenoise][linenoise]]. Planck also
   makes the ~cljs.repl~ helper functions like ~doc~ and ~find-doc~ available,
   which isn't a given in all ClojureScript REPLs.

   If you ever wanted to use Clojure to write scripts, but were frustrated by
   how slow it boots up, then Planck is for you. You can even add a "shebang"
   line to make scripts self-contained, and Planck provides a handful of
   namespaces that expose JavaScriptCore APIs to interact with the outside
   world.

   To get started [[http://planck-repl.org/setup.html][follow the install instructions]], then simply run ~planck~ and
   try it out!

   Planck comes with comprehensive built-in documentation of all supported
   command line flags. For more in-depth info check out [[http://planck-repl.org/guide.html][the Planck User Guide]].

   #+BEGIN_SRC sh
   $ planck -h
   #+END_SRC

   Here's an example of a Planck script that uses the Github API to show the
   list of repositories for a given user.

#+BEGIN_SRC clojure
#!/usr/bin/env planck
(ns stargazers.main
  (:require [planck.http :as h]))

(defn github-get [path]
  (h/get (str "https://api.github.com" path)
         {:headers {"User-Agent" "Plank 2.0"
                    "Accept" "application/vnd.github.v3+json"}}))

(defn get-repos [username]
  (-> (str "/users/" username "/repos")
      github-get
      :body
      js/JSON.parse
      js->clj))

(defn -main [& args]
  (let [username (first args)]
    (if username
      (doseq [repo (get-repos username)]
        (let [{:strs [name stargazers_count watchers language description]} repo]
          (println (str name " (" language ")\tðŸŸ† : " stargazers_count "\tðŸ‘“ : " watchers))
          (when description
            (println description))
          (println)))
      (println "Usage:  stargazers <github username>"))))

(set! *main-cli-fn* -main)
#+END_SRC

** Lumo

   Lumo has many similarities with Planck. It is a standalone ClojureScript REPL
   suitable for scripting. It is available on Mac, Linux and Windows, so it does
   have a leg up on Planck when it comes to platform support.

   Where Planck is based on JavaScriptCore, Lumo is based on Node.js, thus
   holding the promise of integrating and bridging the gap with the NPM
   ecosystem.

   It is still early days for Lumo, it lacks the documentation that Planck has,
   and also doesn't yet have any of the "ergonomic" features. Nevertheless it's
   a project to watch.

   The easiest way to install Lumo is through npm:

   #+BEGIN_SRC sh
   $ npm install -g lumo-cljs
   #+END_SRC

   You can have a look at its options with

   #+BEGIN_SRC sh
   $ lumo -h
   #+END_SRC

   The only other source of information so far is a scant [[https://github.com/anmonteiro/lumo][README in the Lumo
   repository]], and the [[https://anmonteiro.com/2016/11/the-fastest-clojure-repl-in-the-world/][Announcement Blog Post]].

** Calvin

   [[https://github.com/eginez/calvin][Calvin]] is not a REPL itself, but an invaluable tool when working with Planck
   or Lumo. Both REPLs are able to load ClojureScript namespaces from JARs, but
   you need to manually manage the classpath.

   Calvin makes your life easier by parsing the ~project.clj~ file, and figuring
   out the right classpath for the current project, so all the libraries that it
   depends on are available from a ClojureScript REPL.

   Calvin is still alpha level software.

** Replumb

   Not a full featured REPL in itself, but still worthy of a mention. Building
   on top of bootstrapped ClojureScript isn't for the faint of heart. There's
   still a lot of infrastructure you need to provide depending on the
   environment you're targeting, and your specific use case. [[https://github.com/Lambda-X/replumb][Replumb]] tries to
   get most of that boilerplate out of the way so you can focus on building cool
   stuff.

** KLIPSE

   [[http://app.klipse.tech/][Klipse]] is a "fiddle" style web-based playground for ClojureScript. Enter some
   ClojureScript, and it will show you the compiled JavaScript, as well as the
   output from running your code.

   Klipse is built on [[Replumb][Replumb]]. With the [[https://github.com/viebel/klipse][Klipse plug-in]] you can add make code
   snippets interactive, for example in library documentation or in a blog post.

** Node.js bootstrapped REPL

   We already talked about the [[Node.js][Node.js]] REPL that comes with ClojureScript. That
   one still requires Clojure though, just like the other built-in REPLs.

   It's also possible to build a Node.js based REPL with bootstrapped
   ClojureScript, which is what the author of the [[https://www.npmjs.com/package/cljs-repl][cljs-repl NPM package]] did.

   The package hasn't been updated since it's first release, and the version of
   ClojureScript it's based on is getting out of date. For most purposes if
   you're on a supported platform you're better of going with [[Planck][Planck]]. cljs-repl
   is still a fun package to play around with though, since it allows you to use
   Node.js' API's from ClojureScript scripts.

* Editor Integration

  Editors and IDEs offer various degrees of REPL integration, providing a rich
  and interactive development workflow.

  /This section is a stub, you can [[Contributing to This Guide][help by expanding it]]./

** Emacs
*** inf-clojure

    Emacs has a built-in mode for communicating with a LISP REPL process, called
    ~inferior-lisp~. It works by spinning up a subprocess, and then sending
    forms to be evaluated to that process's standard input stream.

    [[https://github.com/clojure-emacs/inf-clojure][inf-clojure]] follows the same pattern, but is tailored for Clojure REPLs.
    Note that it does not use the nREPL protocol, it simply sends code back and
    forth, and so can't distinguish between a REPL return value, and output
    generated by the code.

*** CIDER

    [[https://github.com/clojure-emacs/cider][CIDER]] is the "everything but the kitchen sink" Clojure integration for
    Emacs. It provides an nREPL-based REPL, in-buffer evaluation, but also many
    extra features. It can do "jump-to-symbol" style code navigation, will show
    the signature of the function at point in the minibuffer, has shortcuts for
    consulting docstrings and javadocs, and much more.

    Its basic features build upon the standard nREPL functionality, for more
    advanced uses it uses a Leiningen plugins which injects the cider-nrepl
    middleware, providing extra nREPL operations. (See [[Custom Middleware][nREPL: Custom Middleware]])

*** clj-refactor

    [[https://github.com/clojure-emacs/clj-refactor.el][clj-refactor.el on Github]]

    Not a REPL but worthy of mention because it's based on nREPL, this Emacs
    extension provides many powerful refactoring tools, "introduce let",
    "extract function", "add project dependency", etc.

    Just like CIDER it uses a Leiningen plugin to inject the refactor-nrepl
    middleware. When using ~cider-jack-in~ this plugin will be added
    automatically. If you're not using CIDER or launching your own nREPL server
    then it's your responsibility to make sure this middleware is loaded.

*** Monroe

    [[https://github.com/sanel/monroe][Monroe]] is an nREPL client for Emacs that fits into the sweet spot between
    the minimalism of ~inf-clojure~ and the mastodont that is ~CIDER~.

    Install it with ~(package-install 'monroe)~ and launch with ~M-x monroe~. It
    will ask you for the location of the nREPL server, which you have to start
    yourself, for instance with ~lein repl~.

    Besides a REPL you get some source buffer interaction, like evaluating
    expressions and regions, and looking up documentation.

** Vim Fireplace
** Cursive
** NightCode
** LightTable

* FAQ :noexport:
** Why do/don't I get line editing, history, etc?
